#include <openenclave/host.h>

#include "enclave.h"

// Include the untrusted modelaggregator header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the modelaggregator.edl file.
#include "modelaggregator_u.h"

using namespace std;

char* path = "./enclave/enclave.signed";
uint32_t flags = OE_ENCLAVE_FLAG_DEBUG | OE_ENCLAVE_FLAG_SIMULATE;

// Helper function used to copy double pointers from untrusted memory to enclave memory
void copy_arr_to_enclave(uint8_t* dst[], size_t num, uint8_t* src[], size_t lengths[]) {
  for (int i = 0; i < num; i++) {
    size_t nlen = lengths[i];
    dst[i] = new uint8_t[nlen];
    memcpy((void*) dst[i], (const void*) src[i], nlen);
  }
}


// This is the function that the Python code will call into.
// Returns 0 on success.
int host_modelaggregator(uint8_t*** encrypted_accumulator, 
        size_t* accumulator_lengths,
        size_t accumulator_length, 
        uint8_t** encrypted_old_params,
        size_t old_params_length,
        uint8_t*** encrypted_new_params_ptr,
        size_t* new_params_length)
{
    oe_result_t error;

    // Create the enclave
    Enclave enclave(path, flags);
    error = enclave.getEnclaveRet();
    if (error != OE_OK) {
        fprintf(
            stderr,
            "oe_create_modelaggregator_enclave(): result=%u (%s)\n",
            error,
            oe_result_str(error));
        return NULL;
    }

    error = enclave_modelaggregator(enclave.getEnclave(), 
            encrypted_accumulator, 
            accumulator_lengths, 
            accumulator_length, 
            encrypted_old_params, 
            old_params_length, 
            encrypted_new_params_ptr,
            new_params_length);

    if (error != OE_OK) {
        fprintf(
            stderr,
            "calling into enclave_modelaggregator failed: result=%u (%s)\n",
            error,
            oe_result_str(error));
        return 1;
    }
    
    return 0;
}

